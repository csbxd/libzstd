Subject: [PATCH] chore: fix CCGO compilation.(remove platform specific optimizations)
---
Index: build/single_file_libs/zstd-in.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build/single_file_libs/zstd-in.c b/build/single_file_libs/zstd-in.c
--- a/build/single_file_libs/zstd-in.c	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/build/single_file_libs/zstd-in.c	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -49,6 +49,7 @@
 #define ZSTD_TRACE 0
 /* TODO: Can't amalgamate ASM function */
 #define ZSTD_DISABLE_ASM 1
+#define ZSTD_NO_INTRINSICS 1
 
 /* Include zstd_deps.h first with all the options we need enabled. */
 #define ZSTD_DEPS_NEED_MALLOC
Index: build/single_file_libs/zstddeclib-in.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build/single_file_libs/zstddeclib-in.c b/build/single_file_libs/zstddeclib-in.c
--- a/build/single_file_libs/zstddeclib-in.c	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/build/single_file_libs/zstddeclib-in.c	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -45,6 +45,7 @@
 #define ZSTD_TRACE 0
 /* TODO: Can't amalgamate ASM function */
 #define ZSTD_DISABLE_ASM 1
+#define ZSTD_NO_INTRINSICS 1
 
 /* Include zstd_deps.h first with all the options we need enabled. */
 #define ZSTD_DEPS_NEED_MALLOC
Index: lib/common/bits.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/common/bits.h b/lib/common/bits.h
--- a/lib/common/bits.h	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/lib/common/bits.h	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -93,23 +93,7 @@
 MEM_STATIC unsigned ZSTD_countTrailingZeros64(U64 val)
 {
     assert(val != 0);
-#if defined(_MSC_VER) && defined(_WIN64)
-#  if STATIC_BMI2
-    return (unsigned)_tzcnt_u64(val);
-#  else
-    if (val != 0) {
-        unsigned long r;
-        _BitScanForward64(&r, val);
-        return (unsigned)r;
-    } else {
-        __assume(0); /* Should not reach this code path */
-    }
-#  endif
-#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(__LP64__)
-    return (unsigned)__builtin_ctzll(val);
-#elif defined(__ICCARM__)
-    return (unsigned)__builtin_ctzll(val);
-#else
+
     {
         U32 mostSignificantWord = (U32)(val >> 32);
         U32 leastSignificantWord = (U32)val;
@@ -119,7 +103,7 @@
             return ZSTD_countTrailingZeros32(leastSignificantWord);
         }
     }
-#endif
+
 }
 
 MEM_STATIC unsigned ZSTD_countLeadingZeros64(U64 val)
Index: lib/common/cpu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/common/cpu.h b/lib/common/cpu.h
--- a/lib/common/cpu.h	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/lib/common/cpu.h	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -30,117 +30,12 @@
 } ZSTD_cpuid_t;
 
 MEM_STATIC ZSTD_cpuid_t ZSTD_cpuid(void) {
-    U32 f1c = 0;
-    U32 f1d = 0;
-    U32 f7b = 0;
-    U32 f7c = 0;
-#if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
-#if !defined(_M_X64) || !defined(__clang__) || __clang_major__ >= 16
-    int reg[4];
-    __cpuid((int*)reg, 0);
-    {
-        int const n = reg[0];
-        if (n >= 1) {
-            __cpuid((int*)reg, 1);
-            f1c = (U32)reg[2];
-            f1d = (U32)reg[3];
-        }
-        if (n >= 7) {
-            __cpuidex((int*)reg, 7, 0);
-            f7b = (U32)reg[1];
-            f7c = (U32)reg[2];
-        }
-    }
-#else
-    /* Clang compiler has a bug (fixed in https://reviews.llvm.org/D101338) in
-     * which the `__cpuid` intrinsic does not save and restore `rbx` as it needs
-     * to due to being a reserved register. So in that case, do the `cpuid`
-     * ourselves. Clang supports inline assembly anyway.
-     */
-    U32 n;
-    __asm__(
-        "pushq %%rbx\n\t"
-        "cpuid\n\t"
-        "popq %%rbx\n\t"
-        : "=a"(n)
-        : "a"(0)
-        : "rcx", "rdx");
-    if (n >= 1) {
-      U32 f1a;
-      __asm__(
-          "pushq %%rbx\n\t"
-          "cpuid\n\t"
-          "popq %%rbx\n\t"
-          : "=a"(f1a), "=c"(f1c), "=d"(f1d)
-          : "a"(1)
-          :);
-    }
-    if (n >= 7) {
-      __asm__(
-          "pushq %%rbx\n\t"
-          "cpuid\n\t"
-          "movq %%rbx, %%rax\n\t"
-          "popq %%rbx"
-          : "=a"(f7b), "=c"(f7c)
-          : "a"(7), "c"(0)
-          : "rdx");
-    }
-#endif
-#elif defined(__i386__) && defined(__PIC__) && !defined(__clang__) && defined(__GNUC__)
-    /* The following block like the normal cpuid branch below, but gcc
-     * reserves ebx for use of its pic register so we must specially
-     * handle the save and restore to avoid clobbering the register
-     */
-    U32 n;
-    __asm__(
-        "pushl %%ebx\n\t"
-        "cpuid\n\t"
-        "popl %%ebx\n\t"
-        : "=a"(n)
-        : "a"(0)
-        : "ecx", "edx");
-    if (n >= 1) {
-      U32 f1a;
-      __asm__(
-          "pushl %%ebx\n\t"
-          "cpuid\n\t"
-          "popl %%ebx\n\t"
-          : "=a"(f1a), "=c"(f1c), "=d"(f1d)
-          : "a"(1));
-    }
-    if (n >= 7) {
-      __asm__(
-          "pushl %%ebx\n\t"
-          "cpuid\n\t"
-          "movl %%ebx, %%eax\n\t"
-          "popl %%ebx"
-          : "=a"(f7b), "=c"(f7c)
-          : "a"(7), "c"(0)
-          : "edx");
-    }
-#elif defined(__x86_64__) || defined(_M_X64) || defined(__i386__)
-    U32 n;
-    __asm__("cpuid" : "=a"(n) : "a"(0) : "ebx", "ecx", "edx");
-    if (n >= 1) {
-      U32 f1a;
-      __asm__("cpuid" : "=a"(f1a), "=c"(f1c), "=d"(f1d) : "a"(1) : "ebx");
-    }
-    if (n >= 7) {
-      U32 f7a;
-      __asm__("cpuid"
-              : "=a"(f7a), "=b"(f7b), "=c"(f7c)
-              : "a"(7), "c"(0)
-              : "edx");
-    }
-#endif
-    {
-        ZSTD_cpuid_t cpuid;
-        cpuid.f1c = f1c;
-        cpuid.f1d = f1d;
-        cpuid.f7b = f7b;
-        cpuid.f7c = f7c;
-        return cpuid;
-    }
+    ZSTD_cpuid_t cpuid;
+    cpuid.f1c = 0;
+    cpuid.f1d = 0;
+    cpuid.f7b = 0;
+    cpuid.f7c = 0;
+    return cpuid;
 }
 
 #define X(name, r, bit)                                                        \
Index: lib/compress/zstd_compress_internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/compress/zstd_compress_internal.h b/lib/compress/zstd_compress_internal.h
--- a/lib/compress/zstd_compress_internal.h	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/lib/compress/zstd_compress_internal.h	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -630,17 +630,9 @@
 MEM_STATIC const BYTE*
 ZSTD_selectAddr(U32 index, U32 lowLimit, const BYTE* candidate, const BYTE* backup)
 {
-#if defined(__GNUC__) && defined(__x86_64__)
-    __asm__ (
-        "cmp %1, %2\n"
-        "cmova %3, %0\n"
-        : "+r"(candidate)
-        : "r"(index), "r"(lowLimit), "r"(backup)
-        );
-    return candidate;
-#else
+
     return index >= lowLimit ? candidate : backup;
-#endif
+
 }
 
 /* ZSTD_noCompressBlock() :
Index: lib/compress/zstd_fast.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/compress/zstd_fast.c b/lib/compress/zstd_fast.c
--- a/lib/compress/zstd_fast.c	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/lib/compress/zstd_fast.c	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -118,9 +118,7 @@
      */
     if (MEM_read32(currentPtr) != MEM_read32(mvalAddr)) return 0;
     /* force ordering of these tests, which matters once the function is inlined, as they become branches */
-#if defined(__GNUC__)
-    __asm__("");
-#endif
+
     return matchIdx >= idxLowLimit;
 }
 
Index: lib/compress/zstd_lazy.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/compress/zstd_lazy.c b/lib/compress/zstd_lazy.c
--- a/lib/compress/zstd_lazy.c	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/lib/compress/zstd_lazy.c	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -1609,12 +1609,7 @@
     }
 
     /* Match Loop */
-#if defined(__GNUC__) && defined(__x86_64__)
-    /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
-     * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
-     */
-    __asm__(".p2align 5");
-#endif
+
     while (ip < ilimit) {
         size_t matchLength=0;
         size_t offBase = REPCODE1_TO_OFFBASE;
@@ -2007,12 +2002,7 @@
     }
 
     /* Match Loop */
-#if defined(__GNUC__) && defined(__x86_64__)
-    /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
-     * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
-     */
-    __asm__(".p2align 5");
-#endif
+
     while (ip < ilimit) {
         size_t matchLength=0;
         size_t offBase = REPCODE1_TO_OFFBASE;
Index: lib/decompress/zstd_decompress_block.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/decompress/zstd_decompress_block.c b/lib/decompress/zstd_decompress_block.c
--- a/lib/decompress/zstd_decompress_block.c	(revision f42dee27b6635ea7a78833c436e42703aa12533a)
+++ b/lib/decompress/zstd_decompress_block.c	(revision af64ce6a981f73cf91cbca80e3aedf78c0a7ad55)
@@ -1597,21 +1597,7 @@
                 *
                 *   https://gist.github.com/terrelln/9889fc06a423fd5ca6e99351564473f4
                 */
-#if defined(__GNUC__) && defined(__x86_64__)
-            __asm__(".p2align 6");
-#  if __GNUC__ >= 7
-	    /* good for gcc-7, gcc-9, and gcc-11 */
-            __asm__("nop");
-            __asm__(".p2align 5");
-            __asm__("nop");
-            __asm__(".p2align 4");
-#    if __GNUC__ == 8 || __GNUC__ == 10
-	    /* good for gcc-8 and gcc-10 */
-            __asm__("nop");
-            __asm__(".p2align 3");
-#    endif
-#  endif
-#endif
+
 
             /* Handle the initial state where litBuffer is currently split between dst and litExtraBuffer */
             for ( ; nbSeq; nbSeq--) {
@@ -1660,22 +1646,6 @@
         if (nbSeq > 0) {
             /* there is remaining lit from extra buffer */
 
-#if defined(__GNUC__) && defined(__x86_64__)
-            __asm__(".p2align 6");
-            __asm__("nop");
-#  if __GNUC__ != 7
-            /* worse for gcc-7 better for gcc-8, gcc-9, and gcc-10 and clang */
-            __asm__(".p2align 4");
-            __asm__("nop");
-            __asm__(".p2align 3");
-#  elif __GNUC__ >= 11
-            __asm__(".p2align 3");
-#  else
-            __asm__(".p2align 5");
-            __asm__("nop");
-            __asm__(".p2align 3");
-#  endif
-#endif
 
             for ( ; nbSeq ; nbSeq--) {
                 seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset, nbSeq==1);
@@ -1759,19 +1729,7 @@
         ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);
         assert(dst != NULL);
 
-#if defined(__GNUC__) && defined(__x86_64__)
-            __asm__(".p2align 6");
-            __asm__("nop");
-#  if __GNUC__ >= 7
-            __asm__(".p2align 5");
-            __asm__("nop");
-            __asm__(".p2align 3");
-#  else
-            __asm__(".p2align 4");
-            __asm__("nop");
-            __asm__(".p2align 3");
-#  endif
-#endif
+
 
         for ( ; nbSeq ; nbSeq--) {
             seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset, nbSeq==1);
